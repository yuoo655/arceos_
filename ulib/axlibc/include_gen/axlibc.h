/* Generated by cbindgen and build.rs, DO NOT edit! */

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>
#include <time.h>
#include <sys/epoll.h>
#include <sys/socket.h>
#include <sys/select.h>
#include <sys/time.h>
#include <pthread.h>
#include "axconfig.h"

#define AX_FILE_LIMIT 1024

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

extern int errno;

/**
 * Abort the current process.
 */
void ax_panic(void) __attribute__((noreturn));

/**
 * Exits the current thread.
 */
void ax_exit(int exit_code) __attribute__((noreturn));

/**
 * Close a file by `fd`.
 */
int ax_close(int fd);

/**
 * Read data from the file indicated by `fd`.
 *
 * Return the read size if success.
 */
ssize_t ax_read(int fd, void *buf, size_t count);

/**
 * Write data to the file indicated by `fd`.
 *
 * Return the written size if success.
 */
ssize_t ax_write(int fd, const void *buf, size_t count);

/**
 * Get file metadata by `fd` and write into `buf`.
 *
 * Return 0 if success.
 */
ssize_t ax_fstat(int fd, struct stat *buf);

/**
 * Duplicate a file descriptor
 */
int ax_dup(int old_fd);

/**
 * `dup3()` is the same as `dup2()`, except that:
 *
 * The caller can force the close-on-exec flag to be set for the new file descriptor by specifying `O_CLOEXEC` in flags.
 *
 * If oldfd equals newfd, then `dup3()` fails with the error `EINVAL`.
 */
int ax_dup3(int old_fd,
            int new_fd,
            int flags);

/**
 * Fcntl implementation
 *
 * TODO: `SET/GET` command is ignored
 */
int ax_fcntl(int fd, int cmd, size_t arg);

/**
 * Open a file by `filename` and insert it into the file descriptor table.
 *
 * Return its index in the file table (`fd`). Return `EMFILE` if it already
 * has the maximum number of files open.
 */
int ax_open(const char *filename, int flags, mode_t mode);

/**
 * Set the position of the file indicated by `fd`.
 *
 * Return its position after seek.
 */
off_t ax_lseek(int fd, off_t offset, int whence);

/**
 * Get the file metadata by `path` and write into `buf`.
 *
 * Return 0 if success.
 */
ssize_t ax_stat(const char *path, struct stat *buf);

/**
 * Get the metadata of the symbolic link and write into `buf`.
 *
 * Return 0 if success.
 */
ssize_t ax_lstat(const char *path, struct stat *buf);

/**
 * Get the path of the current directory.
 */
char *ax_getcwd(char *buf, size_t size);

/**
 * Rename `old` to `new`
 * If new exists, it is first removed.
 *
 * Return 0 if the operation succeeds, otherwise return -1.
 */
int ax_rename(const char *old, const char *new_);

/**
 * `ax_epoll_create()` creates a new epoll instance.
 *
 * `ax_epoll_create()` returns a file descriptor referring to the new epoll instance.
 */
int ax_epoll_create(int size);

/**
 * Control interface for an epoll file descriptor
 */
int ax_epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);

/**
 * `ax_epoll_wait()` waits for events on the epoll instance referred to by the file descriptor epfd.
 */
int ax_epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);

/**
 * Monitor multiple file descriptors, waiting until one or more of the file descriptors become "ready" for some class of I/O operation
 */
int ax_select(int nfds,
              fd_set *readfds,
              fd_set *writefds,
              fd_set *exceptfds,
              struct timeval *timeout);

/**
 * Allocate memory and return the memory address.
 *
 * Returns 0 on failure (the current implementation does not trigger an exception)
 */
void *ax_malloc(size_t size);

/**
 * Deallocate memory.
 *
 * (WARNING) If the address to be released does not match the allocated address, an error should
 * occur, but it will NOT be checked out. This is due to the global allocator `Buddy_system`
 * (currently used) does not check the validity of address to be released.
 */
void ax_free(void *ptr);

/**
 * Create a pipe
 *
 * Return 0 if succeed
 */
int ax_pipe(int *fd1, int *fd2);

/**
 * Get current thread ID.
 */
int ax_getpid(void);

/**
 * Returns the `pthread` struct of current thread.
 */
pthread_t ax_pthread_self(void);

/**
 * Create a new thread with the given entry point and argument.
 *
 * If successful, it stores the pointer to the newly created `struct __pthread`
 * in `res` and returns 0.
 */
int ax_pthread_create(pthread_t *res,
                      const pthread_attr_t *attr,
                      void *(*start_routine)(void *arg),
                      void *arg);

/**
 * Exits the current thread. The value `retval` will be returned to the joiner.
 */
void ax_pthread_exit(void *retval) __attribute__((noreturn));

/**
 * Waits for the given thread to exit, and stores the return value in `retval`.
 */
int ax_pthread_join(pthread_t thread, void **retval);

/**
 * Initialize a mutex.
 */
int ax_pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *_attr);

/**
 * Lock the given mutex.
 */
int ax_pthread_mutex_lock(pthread_mutex_t *mutex);

/**
 * Unlock the given mutex.
 */
int ax_pthread_mutex_unlock(pthread_mutex_t *mutex);

/**
 * Create an socket for communication.
 *
 * Return the socket file descriptor.
 */
int ax_socket(int domain, int socktype, int protocol);

/**
 * Bind a address to a socket.
 *
 * Return 0 if success.
 */
int ax_bind(int socket_fd, const struct sockaddr *socket_addr, socklen_t addrlen);

/**
 * Connects the socket to the address specified.
 *
 * Return 0 if success.
 */
int ax_connect(int socket_fd, const struct sockaddr *socket_addr, socklen_t addrlen);

/**
 * Send a message on a socket to the address specified.
 *
 * Return the number of bytes sent if success.
 */
ssize_t ax_sendto(int socket_fd,
                  const void *buf_ptr,
                  size_t len,
                  int flag,
                  const struct sockaddr *socket_addr,
                  socklen_t addrlen);

/**
 * Send a message on a socket to the address connected.
 *
 * Return the number of bytes sent if success.
 */
ssize_t ax_send(int socket_fd, const void *buf_ptr, size_t len, int flag);

/**
 * Receive a message on a socket and get its source address.
 *
 * Return the number of bytes received if success.
 */
ssize_t ax_recvfrom(int socket_fd,
                    void *buf_ptr,
                    size_t len,
                    int flag,
                    struct sockaddr *socket_addr,
                    socklen_t *addrlen);

/**
 * Receive a message on a socket.
 *
 * Return the number of bytes received if success.
 */
ssize_t ax_recv(int socket_fd, void *buf_ptr, size_t len, int flag);

/**
 * Listen for connections on a socket
 *
 * Return 0 if success.
 */
ssize_t ax_listen(int socket_fd, int backlog);

/**
 * Accept for connections on a socket
 *
 * Return file descriptor for the accepted socket if success.
 */
ssize_t ax_accept(int socket_fd, struct sockaddr *socket_addr, socklen_t *socket_len);

/**
 * Shut down a full-duplex connection.
 *
 * Return 0 if success.
 */
ssize_t ax_shutdown(int socket_fd, int flag);

/**
 * Query addresses for a domain name.
 *
 * Return address number if success.
 */
int ax_getaddrinfo(const char *node, const char *service, struct sockaddr *addrs, size_t len);

/**
 * Get current address to which the socket sockfd is bound.
 */
int ax_getsockname(int sock_fd, struct sockaddr *addr, socklen_t *addrlen);

/**
 * Get peer address to which the socket sockfd is connected.
 */
int ax_getpeername(int sock_fd, struct sockaddr *addr, socklen_t *addrlen);

/**
 * `strftime` implementation
 */
size_t ax_strftime(char *buf, size_t size, const char *format, const struct tm *timeptr);

/**
 * `strtod` implementation
 */
double ax_strtod(const char *s, char **endptr);

/**
 * `strtof`implementation
 */
float ax_strtof(const char *s, char **endptr);

/**
 * `writev` implementation
 */
ssize_t ax_writev(int fd, const struct iovec *iov, int iocnt);

/**
 * Returns a pointer to the global errno variable.
 */
int *__errno_location(void);

/**
 * Returns a pointer to the string representation of the given error code.
 */
char *ax_errno_string(int e);

/**
 * `mktime` implementation
 */
time_t ax_mktime(struct tm *t);

/**
 * Sets the seed for the random number generator.
 */
void ax_srand(uint32_t seed);

/**
 * Returns a 32-bit unsigned pseudo random interger.
 */
uint32_t ax_rand_u32(void);

/**
 * Print a string to the global standard output stream.
 */
int ax_print_str(const char *buf, size_t count);

/**
 * Print a string to the global standard output stream. Add a line break.
 */
int ax_println_str(const char *buf, size_t count);

/**
 * Return system configuration infomation
 *
 * Notice: currently only support what unikraft covers
 */
long ax_sysconf(int name);

/**
 * Get clock time since booting
 */
int ax_clock_gettime(struct timespec *ts);

/**
 * Sleep some nanoseconds
 *
 * TODO: should be woken by signals, and set errno
 */
int ax_nanosleep(const struct timespec *req, struct timespec *rem);

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus
